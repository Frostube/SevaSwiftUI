import crypto from 'crypto';
import { spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import NodeCache from 'node-cache';

export class CompileWorker {
  constructor() {
    // Cache compiled results for 1 hour
    this.cache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });
    this.tempDir = '/tmp/swiftui-compile';
    // Default to mock compiles unless explicitly disabled
    this.useMock = process.env.USE_MOCK !== 'false';
    this.setupTempDirectory();
  }

  async setupTempDirectory() {
    try {
      await fs.mkdir(this.tempDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create temp directory:', error);
    }
  }

  async hashCode(code) {
    return crypto.createHash('sha256').update(code).digest('hex');
  }

  async compile(code, options = {}) {
    const startTime = Date.now();
    const codeHash = await this.hashCode(code);
    
    // Check cache first
    const cached = this.cache.get(codeHash);
    if (cached) {
      console.log(`Cache hit for ${codeHash}`);
      return {
        ...cached,
        cached: true,
        compilationTime: 0
      };
    }

    try {
      console.log(`Compiling code hash: ${codeHash}`);
      
      // Validate and sanitize code
      const sanitizedCode = this.sanitizeCode(code);
      
      // Create temporary files
      const workDir = path.join(this.tempDir, codeHash);
      await fs.mkdir(workDir, { recursive: true });

      let result;
      if (this.useMock) {
        const sourceFile = path.join(workDir, 'main.swift');
        await fs.writeFile(sourceFile, sanitizedCode);
        // Mock compilation
        result = await this.compileWithSwiftWasm(sourceFile, workDir, options);
      } else {
        // Real compilation: prefer local carton inside container if CARTON_MODE=local
        const mode = (process.env.CARTON_MODE || 'docker').toLowerCase();
        if (mode === 'local') {
          result = await this.compileWithCartonLocal(workDir, sanitizedCode, options);
        } else {
          // Docker fallback
          result = await this.compileWithCartonDocker(workDir, sanitizedCode, options);
        }
      }
      
      // Cache the result
      this.cache.set(codeHash, result);
      
      // Cleanup
      await this.cleanup(workDir);
      
      const compilationTime = Date.now() - startTime;
      console.log(`Compilation completed in ${compilationTime}ms for ${codeHash}`);
      
      return {
        ...result,
        cached: false,
        compilationTime
      };
      
    } catch (error) {
      console.error(`Compilation failed for ${codeHash}:`, error);
      throw error;
    }
  }

  sanitizeCode(code) {
    // Remove potentially dangerous imports and functions
    const dangerousPatterns = [
      /import\s+Foundation/gi,
      /import\s+UIKit/gi,
      /import\s+Cocoa/gi,
      /FileManager/gi,
      /NSFileManager/gi,
      /Process\(/gi,
      /system\(/gi,
      /exec\(/gi,
      /@objc/gi,
      /DynamicCallable/gi,
      /DynamicMemberLookup/gi
    ];

    let sanitized = code;
    
    dangerousPatterns.forEach(pattern => {
      sanitized = sanitized.replace(pattern, '// REMOVED_FOR_SECURITY');
    });

    // Ensure we only have SwiftUI and basic Swift
    if (!sanitized.includes('import SwiftUI')) {
      sanitized = 'import SwiftUI\\n\\n' + sanitized;
    }

    return sanitized;
  }

  async compileWithSwiftWasm(sourceFile, workDir, options) {
    const timeout = options.timeout || 10000;
    
    // For now, return a mock result since setting up SwiftWasm is complex
    // In production, this would actually compile with SwiftWasm toolchain
    return new Promise((resolve, reject) => {
      // Mock compilation delay
      setTimeout(() => {
        try {
          // Mock successful compilation
          const mockWasm = this.generateMockWasm();
          const mockJS = this.generateMockJS();
          
          resolve({
            success: true,
            wasm: mockWasm,
            js: mockJS,
            logs: ['Compilation successful'],
            warnings: [],
            errors: []
          });
        } catch (error) {
          reject(error);
        }
      }, Math.random() * 1000 + 500); // 0.5-1.5s delay
    });
  }

  generateMockWasm() {
    // Return a mock WASM module as base64
    // In production, this would be the actual compiled WASM
    const mockWasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, // WASM magic number
      0x01, 0x00, 0x00, 0x00  // WASM version
    ]);
    
    return Buffer.from(mockWasmBytes).toString('base64');
  }

  generateMockJS() {
    // Return mock JavaScript glue code
    // In production, this would be generated by SwiftWasm
    return `
// Mock SwiftUI WebAssembly Runtime
class SwiftUIWasmRuntime {
  constructor(wasmModule) {
    this.wasmModule = wasmModule;
    this.initialized = false;
  }
  
  async initialize() {
    if (this.initialized) return;
    
    // Mock initialization
    console.log('Initializing SwiftUI WASM runtime...');
    this.initialized = true;
  }
  
  render(container) {
    if (!this.initialized) {
      throw new Error('Runtime not initialized');
    }
    
    // Mock rendering - create a simple iOS-style UI
    container.innerHTML = this.generateMockUI();
  }
  
  generateMockUI() {
    return \`
      <div style="
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        padding: 20px;
        background: #000;
        color: white;
        border-radius: 12px;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
      ">
        <div style="font-size: 24px; font-weight: 600;">Hello, SwiftUI!</div>
        <div style="font-size: 16px; color: #999;">Welcome to the web preview</div>
        <button style="
          padding: 8px 16px;
          background: #007AFF;
          color: white;
          border: none;
          border-radius: 8px;
          font-size: 16px;
          cursor: pointer;
        " onclick="console.log('Button tapped!')">Tap me!</button>
      </div>
    \`;
  }
}

// Export for use in preview
window.SwiftUIWasmRuntime = SwiftUIWasmRuntime;
`;
  }

  async cleanup(workDir) {
    try {
      await fs.rm(workDir, { recursive: true, force: true });
    } catch (error) {
      console.warn('Failed to cleanup temp directory:', error);
    }
  }

  // Real SwiftWasm compilation (for future implementation)
  async compileWithRealSwiftWasm(sourceFile, workDir, options) {
    return new Promise((resolve, reject) => {
      const timeout = options.timeout || 10000;
      
      // This would be the actual SwiftWasm compilation command
      const swiftWasmPath = process.env.SWIFTWASM_PATH || '/usr/local/bin/swiftc';
      const args = [
        '-target', 'wasm32-unknown-wasi',
        '-o', path.join(workDir, 'output.wasm'),
        sourceFile
      ];
      
      const child = spawn(swiftWasmPath, args, {
        cwd: workDir,
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      const timeoutId = setTimeout(() => {
        child.kill('SIGKILL');
        reject(new Error('Compilation timeout'));
      }, timeout);

      child.on('close', async (code) => {
        clearTimeout(timeoutId);
        
        if (code === 0) {
          try {
            const wasmPath = path.join(workDir, 'output.wasm');
            const wasmBytes = await fs.readFile(wasmPath);
            const wasmBase64 = wasmBytes.toString('base64');
            
            resolve({
              success: true,
              wasm: wasmBase64,
              js: this.generateMockJS(), // Would generate real JS glue code
              logs: stdout.split('\\n').filter(line => line.trim()),
              warnings: [],
              errors: []
            });
          } catch (error) {
            reject(new Error(`Failed to read compiled WASM: ${error.message}`));
          }
        } else {
          const errors = stderr.split('\\n').filter(line => line.trim());
          reject(new Error(`Compilation failed with code ${code}: ${errors.join('; ')}`));
        }
      });

      child.on('error', (error) => {
        clearTimeout(timeoutId);
        reject(new Error(`Failed to start SwiftWasm compiler: ${error.message}`));
      });
    });
  }

  // Real SwiftWasm compilation via Docker + carton bundle (TokamakDOM)
  async compileWithCartonDocker(workDir, userCode, options) {
    // Create a minimal SwiftPM project that uses TokamakDOM and embeds user's ContentView
    await this.createSwiftPMProject(workDir, userCode);

    const image = process.env.CARTON_IMAGE || 'ghcr.io/swiftwasm/carton:latest';
    const args = [
      'run', '--rm',
      '-v', `${workDir}:/workspace`,
      '-w', '/workspace',
      image,
      'carton', 'bundle', '-c', 'release'
    ];

    const logs = [];
    const warnings = [];
    const timeout = options.timeout || 10000;

    return new Promise((resolve, reject) => {
      let stderr = '';
      const child = spawn('docker', args, { stdio: ['ignore', 'pipe', 'pipe'] });

      child.stdout.on('data', (d) => { const t = d.toString(); logs.push(...t.split('\n')); });
      child.stderr.on('data', (d) => { const t = d.toString(); warnings.push(...t.split('\n')); stderr += t; });

      const to = setTimeout(() => child.kill('SIGKILL'), timeout);

      child.on('error', async (err) => {
        clearTimeout(to);
        // Fallback to mock if Docker/carton not present
        console.warn('Docker/carton unavailable, falling back to mock:', err.message);
        this.useMock = true;
        const sourceFile = path.join(workDir, 'main.swift');
        await fs.writeFile(sourceFile, userCode);
        const mock = await this.compileWithSwiftWasm(sourceFile, workDir, options);
        resolve(mock);
      });

      child.on('close', async (code) => {
        clearTimeout(to);
        if (code !== 0) {
          return reject(new Error(`carton bundle failed: ${stderr.split('\n').slice(-6).join(' ')}`));
        }
        try {
          const { wasmBase64, jsCode } = await this.collectArtifacts(workDir);
          resolve({ success: true, wasm: wasmBase64, js: jsCode, logs, warnings, errors: [] });
        } catch (e) {
          reject(e);
        }
      });
    });
  }

  // Real SwiftWasm compilation by invoking `carton` directly (for container/VM with toolchain preinstalled)
  async compileWithCartonLocal(workDir, userCode, options) {
    await this.createSwiftPMProject(workDir, userCode);

    const logs = [];
    const warnings = [];
    const timeout = options.timeout || 10000;

    return new Promise((resolve, reject) => {
      let stderr = '';
      const child = spawn('carton', ['bundle', '-c', 'release'], { cwd: workDir, stdio: ['ignore', 'pipe', 'pipe'] });

      child.stdout.on('data', (d) => { const t = d.toString(); logs.push(...t.split('\n')); });
      child.stderr.on('data', (d) => { const t = d.toString(); warnings.push(...t.split('\n')); stderr += t; });

      const to = setTimeout(() => child.kill('SIGKILL'), timeout);

      child.on('error', async (err) => {
        clearTimeout(to);
        console.warn('Local carton unavailable, falling back to mock:', err.message);
        this.useMock = true;
        const sourceFile = path.join(workDir, 'main.swift');
        await fs.writeFile(sourceFile, userCode);
        const mock = await this.compileWithSwiftWasm(sourceFile, workDir, options);
        resolve(mock);
      });

      child.on('close', async (code) => {
        clearTimeout(to);
        if (code !== 0) {
          return reject(new Error(`carton bundle (local) failed: ${stderr.split('\n').slice(-6).join(' ')}`));
        }
        try {
          const { wasmBase64, jsCode } = await this.collectArtifacts(workDir);
          resolve({ success: true, wasm: wasmBase64, js: jsCode, logs, warnings, errors: [] });
        } catch (e) {
          reject(e);
        }
      });
    });
  }

  async createSwiftPMProject(workDir, userCode) {
    const pkg = `// swift-tools-version:5.9\nimport PackageDescription\n\nlet package = Package(\n  name: "PreviewApp",\n  platforms: [.macOS(.v12)],\n  products: [.executable(name: "PreviewApp", targets: ["PreviewApp"])],\n  dependencies: [.package(url: "https://github.com/TokamakUI/Tokamak.git", from: "0.12.0")],\n  targets: [.executableTarget(name: "PreviewApp", dependencies: [.product(name: "TokamakDOM", package: "Tokamak")])]\n)\n`;

    const sourcesDir = path.join(workDir, 'Sources', 'PreviewApp');
    await fs.mkdir(sourcesDir, { recursive: true });

    const mainSwift = `#if canImport(TokamakDOM)\nimport TokamakDOM\n#endif\nimport SwiftUI\n\n@main struct PreviewApp: App { var body: some Scene { WindowGroup("App") { ContentView() } } }\n`;
    const contentSwift = this.ensureContentView(userCode);

    await fs.writeFile(path.join(workDir, 'Package.swift'), pkg, 'utf8');
    await fs.writeFile(path.join(sourcesDir, 'main.swift'), mainSwift, 'utf8');
    await fs.writeFile(path.join(sourcesDir, 'ContentView.swift'), contentSwift, 'utf8');
  }

  ensureContentView(code) {
    const hasImport = /\bimport\s+SwiftUI\b/.test(code);
    const hasContentView = /struct\s+ContentView\s*:\s*View/.test(code);
    let prefixed = code.trim();
    if (!hasImport) prefixed = `import SwiftUI\n\n${prefixed}`;
    if (!hasContentView) {
      prefixed += `\n\nstruct ContentView: View { var body: some View { VStack { Text("Preview") } } }`;
    }
    return prefixed + '\n';
  }

  async collectArtifacts(workDir) {
    // Walk workDir to find first .wasm and .js produced by carton bundle
    async function* walk(dir) {
      for (const dirent of await fs.readdir(dir, { withFileTypes: true })) {
        const res = path.resolve(dir, dirent.name);
        if (dirent.isDirectory()) yield* walk(res); else yield res;
      }
    }
    let wasmPath = null, jsPath = null;
    for await (const p of walk(workDir)) {
      if (!wasmPath && p.endsWith('.wasm')) wasmPath = p;
      if (!jsPath && p.endsWith('.js')) jsPath = p;
      if (wasmPath && jsPath) break;
    }
    if (!wasmPath || !jsPath) throw new Error('Failed to locate compiled artifacts (.wasm/.js)');
    const wasmBase64 = (await fs.readFile(wasmPath)).toString('base64');
    const jsCode = await fs.readFile(jsPath, 'utf8');
    return { wasmBase64, jsCode };
  }
}
